package book.andrkotlpro.mycontacts1

import android.os.Bundle
import android.util.Log
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.
    ExperimentalFoundationApi
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.*
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import androidx.compose.runtime.livedata.observeAsState
import androidx.lifecycle.ViewModelProvider
import book.andrkotlpro.mycontacts1.ui.theme.
    MyContacts1Theme
import com.google.accompanist.permissions.*


class MainActivity : ComponentActivity() {
    // The @OptIn is needed, because the library with
    // classes at com.google.accompanist.permissions are
    // experimental
    @OptIn(ExperimentalPermissionsApi::class)
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        // These two lines are all we need to access
        // the model data.
        val myViewModelFactory = 
            ContactsViewModelFactory(application)
        val contactsViewModel = ViewModelProvider(
            this, myViewModelFactory).get(
                ContactsViewModel::class.java)

        setContent { // the UI builder starts here
            // Wrap in a theme. Note that the theme
            // classes are generated by the Studio's
            // 'new project' wizard
            MyContacts1Theme {
                // A surface container using the 
                //'background' color from the theme
                Surface(
                    modifier = Modifier.fillMaxSize(),
                    color = MaterialTheme.colors.background
                ) {
                    // Inquire permission state
                    val contactsPermissionState = 
                        rememberMultiplePermissionsState (
                          listOf(
                          android.Manifest.permission.
                              WRITE_CONTACTS,
                          android.Manifest.permission.
                              READ_CONTACTS
                    ) )
                    with(contactsPermissionState) {
                        if(allPermissionsGranted) {
                            ContactsContentLazy(
                                contactsViewModel)
                        }else{
                            InquirePermission(this)
                        }
                    }
                }
            }
        }
    }
}

// The @Composable is an important JetPack compose feature
// It allows to extract UI builder fragments. This 
// composable requests permissions.
@OptIn(ExperimentalPermissionsApi::class)
@Composable
fun InquirePermission(
       contactsPermissionState: MultiplePermissionsState) {
    val textToShow = 
    if(contactsPermissionState.shouldShowRationale) {
        "Contacts access is important for this app." +
        " Please grant the permission."
    }else{
        "Contacts permission required for this feature" +
        " to be available. Please grant the permission"
    }
    Column() {
        Text(textToShow)
        Button(onClick = { contactsPermissionState.
                launchMultiplePermissionRequest() }) {
            Text("Request permission")
        }
    }
}

// The contacts list
@Composable
fun ContactsContentLazy(viewModel: ContactsViewModel) {
    // Just in case you need it... 
    //val composableScope = rememberCoroutineScope()
    //val ctx = LocalContext.current

    // An important line. The 'observeAsState' makes
    // sure the UI gets recomposed if the underlying
    // data change. It _will_ do so, because by virtue
    // of Coroutines the data get fetched asynchronously 
    val list by viewModel.myContacts.
        observeAsState(mutableListOf())

    // The LazyColumn renders only visible items. It
    // also makes the list view scrollable 
    LazyColumn(modifier = Modifier.padding(16.dp)) {
        //items(list, {itm -> itm.id}) { itm ->
        items(list) { itm ->
            Log.e("LOG", "--------------------------")
            Log.e("LOG", itm.id)
            Log.e("LOG", itm.lookupKey)
            Log.e("LOG", itm.display)
            Log.e("LOG", itm.email)
            Text(
                text = itm.id + "\n  " + itm.display + 
                    "\n  " + itm.email,
                modifier = Modifier.padding(bottom = 8.dp),
                style = MaterialTheme.typography.h5
            )
        }
    }
}
